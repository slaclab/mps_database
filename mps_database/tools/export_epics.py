#!/usr/bin/env python

from mps_config import MPSConfig, models
from mps_names import MpsName
from sqlalchemy import func
import sys
import argparse
import time 
import os

#
# Sample Device Input (i.e. Digital Channel) record:
#
# record(bi, "CentralNode:DIGIN0") {
#     field(DESC, "Test input")
#     field(DTYP, "asynInt32")
#     field(SCAN, "1 second")
#     field(ZNAM, "OK")
#     field(ONAM, "FAULTED")
#     field(INP, "@asyn(CENTRAL_NODE 0 3)DIGITAL_CHANNEL")
#}
verbose=False

def openArchiveFile(archiveLocation, archiveFileName):
  if (archiveLocation==None):
    print 'None?'
    return None

  af=open('{0}/{1}'.format(archiveLocation,archiveFileName), 'w')
  af.write('#\n')
  af.write('# List of Device Input related PVs to be archived\n')
  af.write('# File generated on {0}\n'.format(time.asctime(time.localtime(time.time()))))
  af.write('#\n')
  return af

def printArchive(file, record, interval, type='monitor'):
  if (file!=None):
    file.write('{0}\t{1}\t{2}\n'.format(record, interval, type))

def printRecord(file, recType, recName, fields, infoFields=[]):
  file.write("record({0}, \"{1}\") {{\n".format(recType, recName))
  for name, value in fields:
    file.write("  field({0}, \"{1}\")\n".format(name, value))
  for name, value in infoFields:
    file.write("  info({0}, \"{1}\")\n".format(name, value))
  file.write("}\n\n")

#def getDeviceInputName(session, deviceInput):
#  digitalChannel = session.query(models.DigitalChannel).filter(models.DigitalChannel.id==deviceInput.channel_id).one()
#  device = session.query(models.DigitalDevice).filter(models.DigitalDevice.id==deviceInput.digital_device_id).one()
#  deviceType = session.query(models.DeviceType).filter(models.DeviceType.id==device.device_type_id).one()
#
#  return deviceType.name + ":" + device.area + ":" + str(device.position) + ":" + digitalChannel.name

#def getAnalogDeviceName(session, analogDevice):
#  deviceType = session.query(models.DeviceType).filter(models.DeviceType.id==analogDevice.device_type_id).one()
#
#  return deviceType.name + ":" + analogDevice.area + ":" + str(analogDevice.position)

#
# Create one bi record for each device input (digital device)
# Also creates:
#  ${DEV}_LATCHED
#  ${DEV}_BYPV (bypass value)
#  ${DEV}_BYPS (bypass status)
#  ${DEV}_BYPEXP (bypass expiration date?)
#
def exportDeviceInputs(file, deviceInputs, session, restoreLocation, prodLocation, archiveLocation):
  base_name =  file.name.split('/')[len(file.name.split('/'))-1]
  location = file.name.split(base_name)[0]

  if prodLocation==None:
    prodLocation=location

#  print 'LOCA: {0}'.format(prodLocation)
  saveBypassFile = '{0}{1}.save'.format(prodLocation, base_name.split('.')[0])
  restoreBypassFile = '{0}{1}.restore'.format(restoreLocation, base_name.split('.')[0])
  af = openArchiveFile(archiveLocation, '{0}.archive'.format(base_name.split('.')[0]))
  sf = open(saveBypassFile, 'w')

  # Write function that gets the current bypass time and
  # restores if it is non-zero
  func = \
      '#!/bin/bash\n'                                                + \
      '# This script reads the PVs with the number of remaining\n'   + \
      '# seconds on active bypasses. It should be used prior to\n'   + \
      '# rebooting the MPS Central Node IOC.\n'                      + \
      '#\n'                                                          + \
      '# It reads the *BYPD/*BYPV PVs and generates another script\n'+ \
      '# that will restore the remaining seconds to the *BYPT PVs\n' + \
      '#\n'                                                          + \
      '# This script is generated by the export_epics.py that\n'     + \
      '# is executed as part of the MPS Database release process\n'  + \
      '#\n'                                                          + \
      '# Generated on {0}\n'.format(time.asctime(time.localtime(time.time()))) + \
      '#\n\n'                                                        + \
      'function getBypass {\n'                                       + \
      '  time=`caget -t $1`\n'                                       + \
      '  value=`caget -t -n $3`\n'                                      + \
      '  if [ $? != \'0\' ]; then\n'                                 + \
      '    echo \'ERROR: failed to get bypass status \'$1\n'         + \
      '    echo \'Please try running this script again\'\n'          + \
      '    exit 1\n'                                                 + \
      '  fi\n'                                                       + \
      '  if [ $time != \'0\' ]; then\n'                              + \
      '    echo \'  caput \'$2\' \'${time} >> $5\n'                    + \
      '    echo \'  caput \'$3\' \'${value} >> $5\n'                   + \
      '    echo \'  echo \'$4 >> $5\n'                                 + \
      '    bypassCount=$[bypassCount + 1]\n'                         + \
      '  fi\n'                                                       + \
      '}\n\n'

  sf.write(func)
  sf.write('msg=\'*** This will save the current bypass times and values ***\'\n')
  sf.write('hasRestore=\'0\'\n')
  sf.write('if [ -f {0} ]; then\n'.format(restoreBypassFile))
  sf.write('   hasRestore=\'1\'\n')
  sf.write('   timestamp=`date +\'%m-%d-%y-%H:%M:%S\'`\n')
  sf.write('   newFile={0}-$timestamp\n'.format(restoreBypassFile))
  sf.write('   msg=$msg\'\n\nThe current restore file will be saved with the timestamp \'$timestamp\' in the name\'\n')
  sf.write('fi\n')
  sf.write('\n')
  sf.write('msg=$msg\'\n\nProceed?\'\n')
  sf.write('zenity --question --text "$msg" --ok-label=YES --cancel-label=NO --title "MPS Digital Input Bypass"\n')
  sf.write('\n')
  sf.write('bypassCount=0\n')
  sf.write('if [ $? == \'1\' ]; then\n')
  sf.write('  echo \'Save bypass cancelled.\'\n')
  sf.write('  exit 1\n')
  sf.write('fi\n')
  sf.write('\n')
  sf.write('if [ $hasRestore == \'1\' ]; then\n')
  sf.write('  echo \'INFO: found existing restore file, saving it with current timestamp (\'$newFile\')\'\n')
  sf.write('  mv -f {0} $newFile\n'.format(restoreBypassFile))
  sf.write('fi\n\n')
  sf.write('echo \'INFO: getting current bypasses...\'\n\n')

  # These are the lines in the bypass restore script
  sf.write('echo \'#!/bin/bash \' >> {0}\n'.format(restoreBypassFile))
  sf.write('echo \'# \' >> {0}\n'.format(restoreBypassFile))
  sf.write('echo \'# Bypass restore file generated on \'`date`\'\' >> {0}\n'.format(restoreBypassFile))
  sf.write('echo \'# \' >> {0}\n'.format(restoreBypassFile))
  sf.write('echo \'date="\'`date`\'"\' >> {0}\n'.format(restoreBypassFile))
  sf.write('echo \'msg="This will restore device input (digital) bypasses saved on $date."\' >> {0}\n'.format(restoreBypassFile))
  sf.write('echo \'msg=$msg"\\n\\nProceed?"\' >> {0}\n'.format(restoreBypassFile))
  sf.write('echo \'zenity --question --text "$msg" --ok-label=YES --cancel-label=NO --title "MPS Digital Input Bypass"\' >> {0}\n'.format(restoreBypassFile))

  # zenity --progress start and percentage increase
  sf.write('(\n')
  numInputs=len(deviceInputs)
  if numInputs == 0:
    percentageIncrease=100
  else:
    percentageIncrease=100/numInputs
  percentage=0
  sf.write('echo \'(\' >> {0}\n'.format(restoreBypassFile))
  sf.write('echo \'  bypassCount=0\' >> {0}\n'.format(restoreBypassFile))

  mpsName = MpsName(session)
  for deviceInput in deviceInputs:
#    name = getDeviceInputName(session, deviceInput)
    name = mpsName.getDeviceInputName(deviceInput)
    fields=[]
    fields.append(('DESC', 'CR[{0}], CA[{1}], CH[{2}]'.
                   format(deviceInput.channel.card.crate.id,
                          deviceInput.channel.card.number,
                          deviceInput.channel.number)))
    fields.append(('DTYP', 'asynUInt32Digital'))
    fields.append(('SCAN', '1 second'))
    fields.append(('ZNAM', '{0}'.format(deviceInput.channel.z_name)))
    fields.append(('ONAM', '{0}'.format(deviceInput.channel.o_name)))
    if deviceInput.channel.alarm_state == 0:
      fields.append(('ZSV', 'MAJOR'))
      fields.append(('OSV', 'NO_ALARM'))
    else:
      fields.append(('ZSV', 'NO_ALARM'))
      fields.append(('OSV', 'MAJOR'))

    fields.append(('INP', '@asynMask(CENTRAL_NODE {0} 1 0)MPS_DEVICE_INPUT'.format(deviceInput.id)))
    recName='{0}_MPSC'.format(name)

    printRecord(file, 'bi', recName, fields)
    printArchive(af, recName, 1, 'monitor')

    #=== Begin Latch records ====
    # Record for latched value
    fields[0]=(('DESC', 'CR[{0}], CA[{1}], CH[{2}] Latched Value'.
                format(deviceInput.channel.card.crate.id,
                       deviceInput.channel.card.number,
                       deviceInput.channel.number)))
    fields[7]=(('INP', '@asynMask(CENTRAL_NODE {0} 1 0)MPS_DEVICE_INPUT_LATCHED'.format(deviceInput.id)))
    printRecord(file, 'bi', '{0}_MPS'.format(name), fields)

    # Record to process unlatch value
    fields=[]
    fields.append(('DESC', 'CR[{0}], CA[{1}], CH[{2}] Unlatch'.
                   format(deviceInput.channel.card.crate.id,
                          deviceInput.channel.card.number,
                          deviceInput.channel.number)))
    fields.append(('DTYP', 'asynUInt32Digital'))
    fields.append(('OUT', '@asynMask(CENTRAL_NODE {0} 1 0)MPS_DEVICE_INPUT_UNLATCH'.format(deviceInput.id)))
    printRecord(file, 'bo', '{0}_UNLH'.format(name), fields)
    #=== End Latch records ====

    #=== Begin Bypass records ====
    # Bypass Value: used while bypass is active
    fields=[]
    fields.append(('DESC', 'Bypass Value'))
    fields.append(('DTYP', 'asynUInt32Digital'))
    fields.append(('ZNAM', '{0}'.format(deviceInput.channel.z_name)))
    fields.append(('ONAM', '{0}'.format(deviceInput.channel.o_name)))
    if deviceInput.channel.alarm_state == 0:
      fields.append(('ZSV', 'MAJOR'))
      fields.append(('OSV', 'NO_ALARM'))
    else:
      fields.append(('ZSV', 'NO_ALARM'))
      fields.append(('OSV', 'MAJOR'))
    fields.append(('OUT', '@asynMask(CENTRAL_NODE {0} 1 0)MPS_DEVICE_INPUT_BYPV'.format(deviceInput.id)))
    fields.append(('VAL', '0'))
    fields.append(('PINI', 'YES'))
    bypassValuePv = '{0}_BYPV'.format(name)
    printRecord(file, 'bo', bypassValuePv, fields)

    # Bypass Status: shows if bypass is currently active or not
    fields=[]
    fields.append(('DESC', 'Bypass Status'))
    fields.append(('SCAN', '1 second'))
    fields.append(('DTYP', 'asynUInt32Digital'))    
    fields.append(('ZNAM', 'Not Bypassed'))
    fields.append(('ONAM', 'Bypassed'))
    fields.append(('ZSV', 'NO_ALARM'))
    fields.append(('OSV', 'MAJOR'))
    fields.append(('INP', '@asynMask(CENTRAL_NODE {0} 1 0)MPS_DEVICE_INPUT_BYPS'.format(deviceInput.id)))
    recName='{0}_BYPS'.format(name)
    printRecord(file, 'bi', recName, fields)
    printArchive(af, recName, 60, 'monitor')

    # Bypass Expiration Date: date/time in seconds since Unix epoch for bypass expiration
    fields=[]
    fields.append(('DESC', 'Bypass duration in seconds'))
    fields.append(('DTYP', 'asynInt32'))
    fields.append(('EGU', 'Seconds'))
    fields.append(('VAL', '0'))
    fields.append(('PINI', 'YES'))
    fields.append(('OUT', '@asyn(CENTRAL_NODE {0} 0)MPS_DEVICE_INPUT_BYPEXPDATE'.format(deviceInput.id)))
    bypassTimePv = '{0}_BYPD'.format(name)
    printRecord(file, 'longout', bypassTimePv, fields)

    fields=[]
    fields.append(('DESC', 'Remaining bypass duration is seconds'))
    fields.append(('DTYP', 'asynInt32'))
    fields.append(('EGU', 'Seconds'))
    fields.append(('SCAN', '1 second'))
    fields.append(('VAL', '0'))
    fields.append(('PINI', 'YES'))
    fields.append(('INP', '@asyn(CENTRAL_NODE {0} 0)MPS_DEVICE_INPUT_REMAINING_BYPTIME'.format(deviceInput.id)))
    remainingTimePv = '{0}_BYPT'.format(name)
    printRecord(file, 'longin', remainingTimePv, fields)
    printArchive(af, remainingTimePv, 60, 'monitor')

    fields=[]
    fields.append(('DESC', 'Bypass Expiration Date/Time String'))
    fields.append(('DTYP', 'asynOctetRead'))
    fields.append(('SCAN', '1 second'))
    fields.append(('VAL', 'Invalid'))
    fields.append(('PINI', 'YES'))
    fields.append(('INP', '@asyn(CENTRAL_NODE {0} 0)MPS_DEVICE_INPUT_BYPEXPDATE_STRING'.format(deviceInput.id)))
    printRecord(file, 'stringin', '{0}_BYP_END'.format(name), fields)

    # Write line to get the current bypass time that should be restored after a configuration is reloaded (after reboot) 
    percentage = percentage + percentageIncrease
    sf.write('echo {0}\n'.format(percentage))
    sf.write('getBypass {0} {1} {2} {3} "{4}"\n'.format(remainingTimePv, bypassTimePv,
                                                        bypassValuePv, percentage, restoreBypassFile))

    #=== End Bypass records ====

  sf.write('  echo $bypassCount > /tmp/mps-digital-bypass-count.txt\n')
  sf.write(') |\n')
  sf.write('zenity --progress --percentage=0 --text="Saving digital bypass information..." --auto-close\n')

  sf.write('echo \') |\' >> {0}\n'.format(restoreBypassFile))
  sf.write('echo \'zenity --progress --percentage=0 --text="Restoring digital bypass information..." --auto-close\' >> {0}\n'.format(restoreBypassFile))

  footer = \
      '\n\nbypassCount=`cat /tmp/mps-digital-bypass-count.txt`\n'    + \
      '\n\nif [ $bypassCount == \'0\' ]; then\n'                    + \
      '  echo \'INFO: found no active bypasses\'\n'                 + \
      'else\n'                                                      + \
      '  echo \'INFO: Found \'${bypassCount}\' active bypasses\'\n' + \
      '  echo \'INFO: Please run the script "{0}" to restore bypasses\'\n'.format(restoreBypassFile) + \
      '  chmod a+x "{0}"\n'.format(restoreBypassFile) + \
      'fi\n' + \
      'echo \'Done.\'\n'
  sf.write(footer)
  
  file.close()
  sf.close()

  if (af != None):
    af.close

  os.system('chmod a+x {0}'.format(saveBypassFile))

#
# Create one bi record for each device state for each analog device
#
# For example, the BPMs have threshold bits for X, Y and TMIT. Each
# one of them has a bit mask to identify the fault. The mask
# is passed to asyn as the third parameter within the 
# '@asynMask(PORT ADDR MASK TIMEOUT)' INP record field
#
def exportAnalogDevices(file, analogDevices, session, restoreLocation, prodLocation, archiveLocation):
  mpsName = MpsName(session)

  base_name =  file.name.split('/')[len(file.name.split('/'))-1]
  location = file.name.split(base_name)[0]

  if prodLocation==None:
    prodLocation=location

  saveBypassFile = '{0}{1}.save'.format(prodLocation, base_name.split('.')[0])
  restoreBypassFile = '{0}{1}.restore'.format(restoreLocation, base_name.split('.')[0])
  af = openArchiveFile(archiveLocation, '{0}.archive'.format(base_name.split('.')[0]))
  sf = open(saveBypassFile, 'w')

  # Write function that gets the current bypass time and
  # restores if it is non-zero
  func = \
      '#\n'                                                          + \
      '# This script reads the PVs with the number of remaining\n'   + \
      '# seconds on active bypasses. It should be used prior to\n'   + \
      '# rebooting the MPS Central Node IOC.\n'                      + \
      '#\n'                                                          + \
      '# It reads the *BYPD PVs and generates another script\n'      + \
      '# that will restore the remaining seconds to the *BYPT PVs\n' + \
      '#\n'                                                          + \
      '# This script is generated by the export_epics.py that\n'     + \
      '# is executed as part of the MPS Database release process\n'  + \
      '#\n'                                                          + \
      '# Generated on {0}\n'.format(time.asctime(time.localtime(time.time()))) + \
      '#\n\n'                                                        + \
      'function getBypass {\n'                                       + \
      '  v=`caget -t $1`\n'                                          + \
      '  if [ $? != \'0\' ]; then\n'                                 + \
      '    echo \'ERROR: failed to get bypass status \'$1\n'         + \
      '    echo \'Please try running this script again\'\n'          + \
      '    exit 1\n'                                                 + \
      '  fi\n'                                                       + \
      '  if [ $v != \'0\' ]; then\n'                                 + \
      '    echo \'caput \'$2\' \'${v} >> $4\n'                       + \
      '    echo \'echo \'$3 >> $4\n'                                 + \
      '    bypassCount=$[bypassCount + 1]\n'                         + \
      '  fi\n'                                                       + \
      '}\n\n'

  sf.write(func)
  sf.write('msg=\'*** This will save the current bypass times and values ***\'\n')
  sf.write('hasRestore=\'0\'\n')
  sf.write('if [ -f {0} ]; then\n'.format(restoreBypassFile))
  sf.write('   hasRestore=\'1\'\n')
  sf.write('   timestamp=`date +\'%m-%d-%y-%H:%M:%S\'`\n')
  sf.write('   newFile={0}-$timestamp\n'.format(restoreBypassFile))
  sf.write('   msg=$msg\'\n\nThe current restore file will be saved with the timestamp \'$timestamp\' in the name\'\n')
  sf.write('fi\n')
  sf.write('\n')
  sf.write('msg=$msg\'\n\nProceed?\'\n')
  sf.write('zenity --question --text "$msg" --ok-label=YES --cancel-label=NO --title "MPS Analog Input Bypass"\n')
  sf.write('bypassCount=0\n')
  sf.write('\n')
  sf.write('if [ $? == \'1\' ]; then\n')
  sf.write('  echo \'Save bypass cancelled.\'\n')
  sf.write('  exit 1\n')
  sf.write('fi\n')
  sf.write('\n')
  sf.write('if [ $hasRestore == \'1\' ]; then\n')
  sf.write('  echo \'INFO: found existing restore file, saving it with current timestamp (\'$newFile\')\'\n')
  sf.write('  mv -f {0} $newFile\n'.format(restoreBypassFile))
  sf.write('fi\n\n')
  sf.write('echo \'INFO: getting current bypasses...\'\n\n')

  # These are the lines in the bypass restore script
  sf.write('echo \'#!/bin/bash \' >> {0}\n'.format(restoreBypassFile))
  sf.write('echo \'# \' >> {0}\n'.format(restoreBypassFile))
  sf.write('echo \'# Bypass restore file generated on \'`date`\'\' >> {0}\n'.format(restoreBypassFile))
  sf.write('echo \'# \' >> {0}\n'.format(restoreBypassFile))
  sf.write('echo \'date="\'`date`\'"\' >> {0}\n'.format(restoreBypassFile))
  sf.write('echo \'msg="This will restore analog device bypasses saved on $date."\' >> {0}\n'.format(restoreBypassFile))
  sf.write('echo \'msg=$msg"\\n\\nProceed?"\' >> {0}\n'.format(restoreBypassFile))
  sf.write('echo \'zenity --question --text "$msg" --ok-label=YES --cancel-label=NO --title "MPS Analog Input Bypass"\' >> {0}\n'.format(restoreBypassFile))

  # zenity --progress start and percentage increase
  sf.write('(\n')
  numInputs=len(analogDevices)
  if numInputs == 0:
    percentageIncrease=100
  else:
    percentageIncrease=100/numInputs
  percentage=0
  sf.write('echo \'(\' >> {0}\n'.format(restoreBypassFile))
  sf.write('echo \'  bypassCount=0\' >> {0}\n'.format(restoreBypassFile))

  for analogDevice in analogDevices:
    name = mpsName.getAnalogDeviceName(analogDevice)
    ignored_pv_added=False
    # All these queries are to get the threshold faults
    faultInputs = session.query(models.FaultInput).filter(models.FaultInput.device_id==analogDevice.id).all()
    fault_list={}
    for fi in faultInputs:
      faults = session.query(models.Fault).filter(models.Fault.id==fi.fault_id).all()
      for fa in faults:
        add_pvs = False
        if (not fa.name in fault_list):
          fault_list[fa.name]={}
          fault_list[fa.name]['name']=name
          fault_list[fa.name]['fault']=fa
          fault_list[fa.name]['faultInputs']=[]
          add_pvs = True
        fault_list[fa.name]['faultInputs'].append(fi.id)
        # produce only one set of bypass pvs per analog fault (one bypass control for all thresholds within an integrator)

        # Only one set of PVs should be generated per faultInput (fi)
        # Therefore get the faultStates only once
        if (add_pvs):
          printAnalogRecords(session, file, name, af, sf, fi, fa,
                             analogDevice, fault_list, percentage, restoreBypassFile)

      #=== End Faults
    #=== End Fault Inputs

    ignored_pv_added = printAnalogBypass(file, af, sf, analogDevice, fault_list, percentage, restoreBypassFile, ignored_pv_added)

    percentage = percentage + percentageIncrease
    sf.write('echo {0}\n'.format(percentage))

    #=== Move the bypasses here, there is one bypass per fault in the fault_list  ===

  sf.write('  echo $bypassCount > /tmp/mps-analog-bypass-count.txt\n')
  sf.write(') |\n')
  sf.write('zenity --progress --percentage=0 --text="Saving analog bypass information..." --auto-close\n')

  sf.write('echo \') |\' >> {0}\n'.format(restoreBypassFile))
  sf.write('echo \'zenity --progress --percentage=0 --text="Restoring analog bypass information..." --auto-close\' >> {0}\n'.format(restoreBypassFile))


  footer = \
      '\n\nbypassCount=`cat /tmp/mps-analog-bypass-count.txt`\n'    + \
      '\n\nif [ $bypassCount == \'0\' ]; then\n'                    + \
      '  echo \'INFO: found no active bypasses\'\n'                 + \
      'else\n'                                                      + \
      '  echo \'INFO: Found \'${bypassCount}\' active bypasses\'\n' + \
      '  echo \'INFO: Please run the script "{0}" to restore bypasses\'\n'.format(restoreBypassFile) + \
      '  chmod a+x "{0}"\n'.format(restoreBypassFile) + \
      'fi\n' + \
      'echo \'Done.\'\n'
  
  sf.write(footer)
  
  file.close()
  sf.close()

  os.system('chmod a+x {0}'.format(saveBypassFile))

  file.close()

def getIntegratorIndex(fault):
  faultStates = session.query(models.FaultState).filter(models.FaultState.fault_id==fault.id).all()
  for state in faultStates:
#    print state.device_state.name
    bitIndex=0
    bitFound=False
    while not bitFound:
      b=(state.device_state.mask>>bitIndex) & 1
      if b==1:
        bitFound=True
      else:
        bitIndex=bitIndex+1
        if bitIndex==32:
          done=True
          bitIndex=-1
      if bitIndex==-1:
        print "ERROR: invalid threshold mask (" + hex(state.device_state.mask)
        exit(-1)

      # Convert bitIndex to integrator index
      # BPM: bit 0-7 -> X, bit 8-15 -> Y, bit 16-23 -> TMIT
      # Non-BPM: bit 0-7 -> INT0, bit 8-15 -> INT1, bit 16-23 -> INT2, bit 24-31 -> INT3
      intIndex=0
      if (bitIndex >= 8 and bitIndex <= 15):
        intIndex = 1
      elif (bitIndex >= 16 and bitIndex <= 23):
        intIndex = 2
      elif (bitIndex >= 24 and bitIndex <= 31):
        intIndex = 3

    return intIndex
  
def printAnalogRecords(session, file, name, af, sf, fi, fa, analogDevice, fault_list, percentage, restoreBypassFile):
#  print '  Fault: {0} (fault_input id={1})'.format(fa.name, fi.id)
  faultStates = session.query(models.FaultState).filter(models.FaultState.fault_id==fa.id).all()
  for state in faultStates:
#    print '  FaultState: ' + state.device_state.name
    bitIndex=0
    bitFound=False
    while not bitFound:
      b=(state.device_state.mask>>bitIndex) & 1
      if b==1:
        bitFound=True
      else:
        bitIndex=bitIndex+1
        if bitIndex==32:
          done=True
          bitIndex=-1
    if bitIndex==-1:
      print "ERROR: invalid threshold mask (" + hex(state.device_state.mask)
      exit(-1)

    # Convert bitIndex to integrator index
    # BPM: bit 0-7 -> X, bit 8-15 -> Y, bit 16-23 -> TMIT
    # Non-BPM: bit 0-7 -> INT0, bit 8-15 -> INT1, bit 16-23 -> INT2, bit 24-31 -> INT3
    intIndex=0
    if (bitIndex >= 8 and bitIndex <= 15):
      intIndex = 1
    elif (bitIndex >= 16 and bitIndex <= 23):
      intIndex = 2
    elif (bitIndex >= 24 and bitIndex <= 31):
      intIndex = 3

#          print '    ' + name + ":" + state.device_state.name + ", mask: " + str(bitIndex) + ", fault name: " + fa.name + ", intIndex: " + str(intIndex)
    fields=[]
    fields.append(('DESC', 'Crate[{0}], Card[{1}], Channel[{2}]'.
                   format(analogDevice.channel.card.crate.id,
                          analogDevice.channel.card.number,
                          analogDevice.channel.number)))
    fields.append(('DTYP', 'asynUInt32Digital'))
    fields.append(('SCAN', '1 second'))
    fields.append(('ZNAM', 'IS_OK'))
    fields.append(('ONAM', 'IS_EXCEEDED'))
    fields.append(('ZSV', 'NO_ALARM'))
    fields.append(('OSV', 'MAJOR'))
    fields.append(('INP', '@asynMask(CENTRAL_NODE {0} {1} 0)MPS_ANALOG_DEVICE'.\
                     format(analogDevice.id, state.device_state.mask)))
    recName = '{0}:{1}_MPSC'.format(name, state.device_state.name)
    printRecord(file, 'bi', recName, fields)
    printArchive(af, recName, 1, 'monitor')

    #=== Begin Latch records ====
    # Record for latched value
    fields=[]
    fields.append(('DESC', 'CR[{0}], CA[{1}], CH[{2}] Latched Value'.
                   format(analogDevice.channel.card.crate.id,
                          analogDevice.channel.card.number,
                          analogDevice.channel.number)))
    fields.append(('DTYP', 'asynUInt32Digital'))
    fields.append(('SCAN', '1 second'))
    fields.append(('ZNAM', 'IS_OK'))
    fields.append(('ONAM', 'IS_EXCEEDED'))
    fields.append(('ZSV', 'NO_ALARM'))
    fields.append(('OSV', 'MAJOR'))
    fields.append(('INP', '@asynMask(CENTRAL_NODE {0} {1} 0)MPS_ANALOG_DEVICE_LATCHED'.\
                     format(analogDevice.id, state.device_state.mask)))
    printRecord(file, 'bi', '{0}:{1}_MPS'.format(name, state.device_state.name), fields)

    # Record to process unlatch value
    fields=[]
    fields.append(('DESC', 'CR[{0}], CA[{1}], CH[{2}] Unlatch'.
                   format(analogDevice.channel.card.crate.id,
                          analogDevice.channel.card.number,
                          analogDevice.channel.number)))
    fields.append(('DTYP', 'asynUInt32Digital'))
    fields.append(('OUT', '@asynMask(CENTRAL_NODE {0} {1} 0)MPS_ANALOG_DEVICE_UNLATCH'.\
                     format(analogDevice.id, state.device_state.mask)))
    printRecord(file, 'bo', '{0}:{1}_UNLH'.format(name, state.device_state.name), fields)
    #=== End Latch records ====
  #=== End States 

def printAnalogBypass(file, af, sf, analogDevice, fault_list, percentage, restoreBypassFile, ignored_pv_added):
  intIndex = 0
  for k, v in fault_list.items():
    fa = v['fault']
    name = v['name']
    intIndex = getIntegratorIndex(fa)

    # Bypass Status: shows if bypass is currently active or not
    fields=[]
    fields.append(('DESC', 'Bypass Status'))
    fields.append(('SCAN', '1 second'))
    fields.append(('DTYP', 'asynInt32'))    
    fields.append(('ZNAM', 'Not Bypassed'))
    fields.append(('ONAM', 'Bypassed'))
    fields.append(('ZSV', 'NO_ALARM'))
    fields.append(('OSV', 'MAJOR'))
    fields.append(('INP', '@asyn(CENTRAL_NODE {0} {1})MPS_ANALOG_DEVICE_BYPS'.\
                     format(analogDevice.id, intIndex)))
    recName = '{0}:{1}_BYPS'.format(name, fa.name)
    printRecord(file, 'bi', recName, fields)
    printArchive(af, recName, 60, 'monitor')
  
    # Bypass Expiration Date: date/time in seconds since Unix epoch for bypass expiration
    fields=[]
    fields.append(('DESC', 'Bypass duration in seconds'))
    fields.append(('DTYP', 'asynInt32'))
    fields.append(('VAL', '0'))
    fields.append(('PINI', 'YES'))
    fields.append(('OUT', '@asyn(CENTRAL_NODE {0} {1})MPS_ANALOG_DEVICE_BYPEXPDATE'.\
                     format(analogDevice.id, intIndex)))
    bypassTimePv = '{0}:{1}_BYPD'.format(name, fa.name)
    printRecord(file, 'longout', bypassTimePv, fields)
  
    fields=[]
    fields.append(('DESC', 'Remaining bypass duration is seconds'))
    fields.append(('DTYP', 'asynInt32'))
    fields.append(('EGU', 'Seconds'))
    fields.append(('SCAN', '1 second'))
    fields.append(('VAL', '0'))
    fields.append(('PINI', 'YES'))
    fields.append(('INP', '@asyn(CENTRAL_NODE {0} {1})MPS_ANALOG_DEVICE_REMAINING_BYPTIME'.\
                     format(analogDevice.id, intIndex)))
    remainingTimePv = '{0}:{1}_BYPT'.format(name, fa.name)
    printRecord(file, 'longin', remainingTimePv, fields)
    printArchive(af, remainingTimePv, 60, 'monitor')
    
    fields=[]
    fields.append(('DESC', 'Bypass Expiration Date/Time String'))
    fields.append(('DTYP', 'asynOctetRead'))
    fields.append(('SCAN', '1 second'))
    fields.append(('VAL', 'Invalid'))
    fields.append(('PINI', 'YES'))
    fields.append(('INP', '@asyn(CENTRAL_NODE {0} 0)MPS_ANALOG_DEVICE_BYPEXPDATE_STRING'.format(analogDevice.id * 4 +  intIndex)))
    printRecord(file, 'stringin', '{0}:{1}_BYP_END'.format(name, fa.name), fields)

    # Add a IGNORED PV only if device appears in an ignoreCondition
    ignore_condition = session.query(models.IgnoreCondition).\
        filter(models.IgnoreCondition.analog_device_id==analogDevice.id).all()
    if len(ignore_condition) > 0:
      asynMask = '@asynMask(CENTRAL_NODE {0} 1 0)MPS_ANALOG_DEVICE_IGNORED'.format(analogDevice.id)
#    print '{0} {1}'.format(name, len(ignore_condition))
      ignored_pv_fs = False
      for i in ignore_condition:
        # if there is an ignore condition where there is an analogDevice AND a faultState, then
        # the asynMask for the record is different, it must return the ignored state for the faultState,
        # not from the analogDevice. The ignored state for the faultState is stored in the
        # analogDevice.ignoredIntegrator array (see central_node_engine.cc file)
        if i.fault_state_id != None:
          faultState = session.query(models.FaultState).filter(models.FaultState.id==i.fault_state_id).one()
          deviceState = session.query(models.DeviceState).filter(models.DeviceState.id==faultState.device_state_id).one()
          if deviceState.get_integrator() == intIndex:
            asynMask = '@asynMask(CENTRAL_NODE {0} 1 {1})MPS_ANALOG_DEVICE_IGNORED_INTEGRATOR'.format(analogDevice.id, intIndex)
            ignored_pv_fs = True # Make sure the PV is added for this specific case

      if (not ignored_pv_added or ignored_pv_fs):
        fields=[]
        fields.append(('DESC', 'Ignored status'))
        fields.append(('DTYP', 'asynUInt32Digital'))
        fields.append(('SCAN', '1 second'))
        fields.append(('ZNAM', 'Not Ignored'))
        fields.append(('ONAM', 'Ignored'))
        fields.append(('ZSV', 'NO_ALARM'))
        fields.append(('OSV', 'MAJOR'))
        fields.append(('INP', asynMask))
        if (ignored_pv_fs):
          printRecord(file, 'bi', '{0}:{1}_IGN'.format(name, fa.name), fields)
        else:
          printRecord(file, 'bi', '{0}:MPSC_IGN'.format(name, fa.name), fields)
        ignored_pv_added = True
  
    # Write line to get the current bypass time that should be restored after a configuration is reloaded (after reboot) 
    sf.write('getBypass {0} {1} {2} "{3}"\n'.format(remainingTimePv, bypassTimePv, percentage, restoreBypassFile))

  return ignored_pv_added

def exportBeamDestinations(file, beamDestinations, beamClasses, session, archiveLocation):
  mpsName = MpsName(session)

  base_name =  file.name.split('/')[len(file.name.split('/'))-1]
  af = openArchiveFile(archiveLocation, '{0}.archive'.format(base_name.split('.')[0]))

  fields=[]
  fields.append(('DESC', 'Total number of beam power classes'))
  fields.append(('PINI', 'YES'))
  fields.append(('VAL', '{0}'.format((len(beamClasses)))))
  printRecord(file, 'longout', '$(BASE):NUM_PC', fields)

  for beamClass in beamClasses:
    fields=[]
    fields.append(('DESC', '{0}'.format(beamClass.description)))
    fields.append(('PINI', 'YES'))
    fields.append(('VAL', '{0}'.format(beamClass.number)))
    printRecord(file, 'longout', '$(BASE):PC_{0}'.format(beamClass.number), fields)

  for beamDestination in beamDestinations:
    name = mpsName.getBeamDestinationName(beamDestination)

    fields=[]
    fields.append(('DESC', 'Software mitigation for: {0}'.format(beamDestination.name)))
    fields.append(('DTYP', 'asynInt32'))
    fields.append(('SCAN', '1 second'))
    fields.append(('LOLO', '0'))
    fields.append(('LLSV', 'MAJOR'))
    fields.append(('INP', '@asyn(CENTRAL_NODE {0} 0)MPS_SW_MITIGATION'.format(beamDestination.id))) # former MITIGATION_DEVICE
    recName = '$(BASE):{0}_SW_PC'.format(beamDestination.name.upper())
    printRecord(file, 'longin', recName, fields)
    printArchive(af, recName, 1, 'scan')
            
    fields=[]
    fields.append(('DESC', 'Fast mitigation for {0}'.format(beamDestination.name)))
    fields.append(('DTYP', 'asynInt32'))
    fields.append(('SCAN', '1 second'))
    fields.append(('LOLO', '0'))
    fields.append(('LLSV', 'MAJOR'))
    fields.append(('INP', '@asyn(CENTRAL_NODE {0} 0)MPS_FW_MITIGATION'.format(beamDestination.id)))
    recName = '$(BASE):{0}_FW_PC'.format(beamDestination.name.upper())
    printRecord(file, 'longin', recName, fields)
    printArchive(af, recName, 1, 'scan')

    fields=[]
    fields.append(('DESC', 'Current mitigation for {0}'.format(beamDestination.name)))
    fields.append(('DTYP', 'asynInt32'))
    fields.append(('SCAN', '1 second'))
    fields.append(('LOLO', '0'))
    fields.append(('LLSV', 'MAJOR'))
    fields.append(('INP', '@asyn(CENTRAL_NODE {0} 0)MPS_MITIGATION'.format(beamDestination.id)))
    recName = '$(BASE):{0}_PC'.format(beamDestination.name.upper())
    printRecord(file, 'longin', recName, fields)
    printArchive(af, recName, 1, 'scan')

    fields=[]
    fields.append(('DESC', 'Latched mitigation for {0}'.format(beamDestination.name)))
    fields.append(('DTYP', 'asynInt32'))
    fields.append(('SCAN', '1 second'))
    fields.append(('LOLO', '0'))
    fields.append(('LLSV', 'MAJOR'))
    fields.append(('INP', '@asyn(CENTRAL_NODE {0} 0)MPS_LATCHED_MITIGATION'.format(beamDestination.id)))
    recName = '$(BASE):{0}_LATCHED_PC'.format(beamDestination.name.upper())
    printRecord(file, 'longin', recName, fields)
    printArchive(af, recName, 1, 'scan')

  file.close()

def exportFaults(file, faults, session, archiveLocation):
  mpsName = MpsName(session)

  base_name =  file.name.split('/')[len(file.name.split('/'))-1]
  af = openArchiveFile(archiveLocation, '{0}.archive'.format(base_name.split('.')[0]))

  for fault in faults:
    name = mpsName.getFaultName(fault)
    fields=[]
    fields.append(('DESC', '{0}'.format(fault.description)))
    fields.append(('DTYP', 'asynUInt32Digital'))
    fields.append(('SCAN', '1 second'))
    fields.append(('ZNAM', 'OK'))
    fields.append(('ONAM', 'FAULTED'))
    fields.append(('ZSV', 'NO_ALARM'))
    fields.append(('OSV', 'MAJOR'))
    fields.append(('INP', '@asynMask(CENTRAL_NODE {0} 1 0)MPS_FAULT'.format(fault.id)))
    recName = '{0}'.format(name)
    printRecord(file, 'bi', recName, fields)
    printArchive(af, recName, 1, 'scan')

    # Nov 12 2018: The DbFault.ignored field is not really used, no need to add PVs
#    fields=[]
#    fields.append(('DESC', '{0}'.format(fault.description)))
#    fields.append(('DTYP', 'asynUInt32Digital'))
#    fields.append(('SCAN', '1 second'))
#    fields.append(('ZNAM', 'Not Ignored'))
#    fields.append(('ONAM', 'Ignored'))
#    fields.append(('ZSV', 'NO_ALARM'))
#    fields.append(('OSV', 'MAJOR'))
#    fields.append(('INP', '@asynMask(CENTRAL_NODE {0} 1 0)MPS_FAULT_IGNORED'.format(fault.id)))
#    recName = '{0}_IGN'.format(name)
#    printRecord(file, 'bi', recName, fields)
#    printArchive(af, recName, 1, 'scan')

    fields=[]
    fields.append(('DESC', '{0}'.format(fault.description)))
    fields.append(('DTYP', 'asynUInt32Digital'))
    fields.append(('SCAN', '1 second'))
    fields.append(('ZNAM', 'OK'))
    fields.append(('ONAM', 'FAULTED'))
    fields.append(('ZSV', 'NO_ALARM'))
    fields.append(('OSV', 'MAJOR'))
    fields.append(('INP', '@asynMask(CENTRAL_NODE {0} 1 0)MPS_FAULT_LATCHED'.format(fault.id)))
    recName = '{0}_MPS'.format(name)
    printRecord(file, 'bi', recName, fields)
    printArchive(af, recName, 1, 'scan')

    fields=[]
    fields.append(('DESC', '{0}'.format(fault.description)))
    fields.append(('DTYP', 'asynUInt32Digital'))
    fields.append(('OUT', '@asynMask(CENTRAL_NODE {0} 1 0)MPS_FAULT_UNLATCH'.format(fault.id)))
    printRecord(file, 'bo', '{0}_UNLH'.format(name), fields)

  file.close()

def exportFaultStates(file, faultStates, session, archiveLocation):
  mpsName = MpsName(session)

  base_name =  file.name.split('/')[len(file.name.split('/'))-1]
  af = openArchiveFile(archiveLocation, '{0}.archive'.format(base_name.split('.')[0]))

  for fs in faultStates:
    name = mpsName.getFaultStateName(fs)
    fields=[]
    fields.append(('DESC', '{0}'.format(fs.device_state.description)))
    fields.append(('DTYP', 'asynUInt32Digital'))
    fields.append(('SCAN', '1 second'))
    fields.append(('ZNAM', 'OK'))
    fields.append(('ONAM', 'FAULTED'))
    fields.append(('ZSV', 'NO_ALARM'))
    fields.append(('OSV', 'MAJOR'))
    fields.append(('INP', '@asynMask(CENTRAL_NODE {0} 1 0)MPS_FAULT_STATE'.format(fs.id)))
    recName = '{0}'.format(name)
    printRecord(file, 'bi', recName, fields)
    printArchive(af, recName, 1, 'scan')

    # Only generate the IGNORED PV if the fault state is present in an IgnoreCondition
    conditions = session.query(models.IgnoreCondition).filter(models.IgnoreCondition.fault_state_id==fs.id).all()
    if (len(conditions) > 0):
      fields=[]
      fields.append(('DESC', '{0}'.format(fs.device_state.description)))
      fields.append(('DTYP', 'asynUInt32Digital'))
      fields.append(('SCAN', '1 second'))
      fields.append(('ZNAM', 'Not Ignored'))
      fields.append(('ONAM', 'Ignored'))
      fields.append(('ZSV', 'NO_ALARM'))
      fields.append(('OSV', 'MAJOR'))
      fields.append(('INP', '@asynMask(CENTRAL_NODE {0} 1 0)MPS_FAULT_STATE_IGNORED'.format(fs.id)))
      recName = '{0}_IGN'.format(name)
      printRecord(file, 'bi', recName, fields)
      printArchive(af, recName, 1, 'scan')

  file.close()

def exportApps(file, apps, session, archiveLocation):
#  mpsName = MpsName(session)
  base_name =  file.name.split('/')[len(file.name.split('/'))-1]
  af = openArchiveFile(archiveLocation, '{0}.archive'.format(base_name.split('.')[0]))

  for app in apps:
    crate = session.query(models.Crate).filter(models.Crate.id==app.crate_id).one()
#    name = mpsName.getFaultName(fault)
    fields=[]
    fields.append(('DESC', '{0} [{1}-{2}{3} S{4} ID{5}]'.format(app.name, crate.location, crate.rack, crate.elevation, app.slot_number, app.global_id)))
    fields.append(('DTYP', 'asynUInt32Digital'))
    fields.append(('SCAN', '1 second'))
    fields.append(('ZNAM', 'OFFLINE'))
    fields.append(('ONAM', 'ONLINE'))
    fields.append(('ZSV', 'MAJOR'))
    fields.append(('OSV', 'NO_ALARM'))
    fields.append(('INP', '@asynMask(CENTRAL_NODE {0} 1 0)MPS_APP_STATUS'.format(app.id)))
    recName = '$(BASE):APP{0}_STATUS'.format(app.id)
    printRecord(file, 'bi', recName, fields)
    printArchive(af, recName, 1, 'scan')

  file.close()

def exportConditions(file, conditions, session, archiveLocation):
  mpsName = MpsName(session)

  base_name =  file.name.split('/')[len(file.name.split('/'))-1]
  af = openArchiveFile(archiveLocation, '{0}.archive'.format(base_name.split('.')[0]))

  for cond in conditions:
    name = mpsName.getConditionName(cond)
    fields=[]
    fields.append(('DESC', '{0}'.format(cond.description)))
    fields.append(('DTYP', 'asynUInt32Digital'))
    fields.append(('SCAN', '1 second'))
    fields.append(('ZNAM', 'False'))
    fields.append(('ONAM', 'True'))
    fields.append(('ZSV', 'NO_ALARM'))
    fields.append(('OSV', 'MAJOR'))
    fields.append(('INP', '@asynMask(CENTRAL_NODE {0} 1 0)MPS_CONDITION'.format(cond.id)))
    recName = '{0}'.format(name)
    printRecord(file, 'bi', recName, fields)
    printArchive(af, recName, 1, 'scan')

  file.close()

#
# Generate records for single channel access MPS input
# PV1: external input - the DOL field is set to the PV listed in monitored_pvs field
#      Scan is 1 second, FLNK field set to PV2. An MPS fault will be generated 
#      if there are HIHI/LOLO alarms and also if the DOL PV gets disconnected
# PV2: calc record that has PV1.STAT and PV1.SEVR as inputs, CALC field is A+B,
#      which should be 0 in there are no faults in PV1. FLNKs to PV3.
# PV3: ao asyn record used as input to the link node sioc. Non-zero values 
#      causes link node to set the MPS fault bit for this input
#
def exportVirtualInput(file, device_input, channel, input_pv, mpsName):
  name = mpsName.getDeviceInputName(device_input)

  fields=[]
  fields.append(('DESC', 'CR[{0}], CA[{1}], CH[{2}]'.
                 format(device_input.channel.card.crate.id,
                        device_input.channel.card.number,
                        device_input.channel.number)))
  fields.append(('PINI', 'YES'))
  fields.append(('OMSL', 'closed_loop'))
  fields.append(('SCAN', '1 second'))
  fields.append(('OIF', 'Full'))
  fields.append(('DOL', '{0}'.format(input_pv)))
  fields.append(('FLNK', '{0}'.format(name + '_CALC')))
  fields.append(('LLSV', 'MAJOR'))
  fields.append(('HHSV', 'MAJOR'))
  infoFields=[]
  infoFields.append(('autosaveVirtualChannels','HIHI LOLO'))
  printRecord(file, 'ao', '{0}'.format(name), fields, infoFields)

  fields=[]
  fields.append(('DESC', 'CR[{0}], CA[{1}], CH[{2}] CALC'.
                 format(device_input.channel.card.crate.id,
                        device_input.channel.card.number,
                        device_input.channel.number)))
  fields.append(('PINI', 'YES'))
  fields.append(('SCAN', 'Passive'))
  fields.append(('FLNK', '{0}'.format(name + '_INPUT')))
  fields.append(('INPA', '{0}.SEVR CPP MS'.format(name)))
  fields.append(('INPB', '{0}.STAT CPP MS'.format(name)))
  fields.append(('CALC', '(A+B)>0?{0}:{1}'.format(channel.alarm_state, int(not channel.alarm_state))))
  printRecord(file, 'calc', '{0}_CALC'.format(name), fields)

  fields=[]
  fields.append(('DESC', 'CR[{0}], CA[{1}], CH[{2}] INP'.
                 format(device_input.channel.card.crate.id,
                        device_input.channel.card.number,
                        device_input.channel.number)))
  fields.append(('PINI', 'YES'))
  fields.append(('OMSL', 'closed_loop'))
  fields.append(('SCAN', 'Passive'))
  fields.append(('DOL', '{0}_CALC'.format(name)))
  fields.append(('DTYP', 'asynUInt32Digital'))
  fields.append(('ZNAM', '{0}'.format(device_input.channel.z_name)))
  fields.append(('ONAM', '{0}'.format(device_input.channel.o_name)))
  if device_input.channel.alarm_state == 0:
    fields.append(('ZSV', 'MAJOR'))
    fields.append(('OSV', 'NO_ALARM'))
  else:
    fields.append(('ZSV', 'NO_ALARM'))
    fields.append(('OSV', 'MAJOR'))
  # The channel.alarm_state gets mapped into the mask read by the LN code
  # MPS faults if the input value matches the channel.alarm_states.
  # Normally the fault is produced when the value is zero (zero volts for
  # actual digital inputs).
  fields.append(('OUT', '@asynMask(MPS_VIRTUAL_CHANNEL {0} {1} 0)MPS_VIRTUAL_INPUT_{2}'.\
                   format(device_input.channel.card.global_id, channel.alarm_state, channel.number)))
  printRecord(file, 'bo', '{0}_INPUT'.format(name), fields)

def exportVirtualCard(link_node, directory, session):
  mpsName = MpsName(session)
  hasVirtual = False
  cards = 0
  virtual_card = None
  for c in link_node.crate.cards:
    if c.name.startswith('Virtual'):
      cards = cards + 1
      virtual_card = c

  # Exit if found multiple cards, or do nothing if there are no cards
  if cards > 1:
    print 'ERROR: Found multiple virtual cards assigned to link node {0}'.\
        format(link_node.get_name())
    exit(-1)
  elif cards == 0:
    return

  # Create directory for link node databases, if that is not available yet
  ln_dir = directory + '/' + link_node.get_name()
  if not os.path.isdir(ln_dir):
    try:
      os.makedirs(ln_dir)
    except:
      print 'ERROR: Failed to create directory {0}'.format(ln_dir)
      exit(-1)
      
  file_name = ln_dir + '/virtual_inputs.db'
  f = open(file_name, 'w')

  if (verbose):
    print ' + {0} ({1})'.format(link_node.get_name(), link_node.crate.location)
  hasVirtual = True

  for d in virtual_card.devices:
    if len(d.inputs) > 1 or len(d.inputs) < 1:
      print 'ERROR: virtual card device must have only one input, found {0} input(s)'.\
          format(len(d.inputs))

    input = d.inputs[0]
    error=False
    if input.channel.num_inputs > 0:
      if (input.channel.num_inputs != len(input.channel.monitored_pvs.split(';'))):
        print 'ERROR: channel {0} of card id {1} number of PV inputs ({2}) does not match with the number of PVs listed ({3}).'.\
            format(input.channel.number, input.channel.card_id, input.channel.num_inputs, len(input.channel.monitored_pvs.split(';')))
        print '       PVs should be separated by semi-colons. This are the PVs found:'
        for s in input.channel.monitored_pvs.split(';'):
          print '       - \'{0}\''.format(s.strip())
        error=True
        softError=True
    if error:
      print 'ERROR: Mismatch between num_inputs ({0}) and monitered_pvs ({1})'.\
          format(input.channel.num_inputs, input.channel.monitered_pvs)
      exit(-1)

    if input.channel.num_inputs == 1:
      exportVirtualInput(f, input, input.channel, input.channel.monitored_pvs, mpsName)

  f.close()
  if not hasVirtual:
    if verbose:
      print ' + no Virtual Cards found.'

def exportLinkNodeDatabases(directory, session):
  if not os.path.isdir(directory):
    print 'ERROR: {0} directory for link node files does not exist'.format(directory)
    exit(-1)

  link_nodes = session.query(models.LinkNode).all()
  if (verbose):
    print 'Virtual Cards:'
  for ln in link_nodes:
    exportVirtualCard(ln, directory, session)

#=== MAIN ==================================================================================

parser = argparse.ArgumentParser(description='Export EPICS template database')

parser.add_argument('database', metavar='db', type=file, nargs=1, 
                    help='database file name (e.g. mps_gun.db)')
parser.add_argument('--link-nodes', metavar='link_node_dir', type=str, nargs='?',
                    help='generate templates for link nodes SIOCs')
parser.add_argument('--device-inputs', metavar='file', type=argparse.FileType('w'), nargs='?',
                    help='epics template file name for digital channels (e.g. device-inputs.template)')
parser.add_argument('--analog-devices', metavar='file', type=argparse.FileType('w'), nargs='?', 
                    help='epics template file name for analog channels (e.g. analog-devices.template)')
parser.add_argument('--beam-destinations', metavar='file', type=argparse.FileType('w'), nargs='?', 
                    help='epics template file name for beam destinations and beam classes (e.g. destinations.template)')
parser.add_argument('--faults', metavar='file', type=argparse.FileType('w'), nargs='?', 
                    help='epics template file name for faults (e.g. faults.template)')
parser.add_argument('--fault-states', metavar='file', type=argparse.FileType('w'), nargs='?', 
                    help='epics template file name for fault states (e.g. fault-states.template)')
parser.add_argument('--apps', metavar='file', type=argparse.FileType('w'), nargs='?',
                    help='epics template file name for application cards (e.g. apps.template)')
parser.add_argument('--conditions', metavar='file', type=argparse.FileType('w'), nargs='?',
                    help='epics template file name for ignore conditions (e.g. conditions.template)')
parser.add_argument('--archive-location', metavar='arch_location', type=str, nargs='?',
                    help='directory where *.archive files are generated, no archive file generated if not specified')
parser.add_argument('--prod-location', metavar='prod_location', type=str, nargs='?', 
                    help='directory where database versions are kept in production (please use $PHYSICS_TOP/mps_config string ;). If not specified use the location pointed by the --location option')
parser.add_argument('--version', metavar='version', type=str, nargs=1,
                    help='database version to be configured')
parser.add_argument('-v', action='store_true', default=False,
                    dest='verbose', help='Verbose output')

args = parser.parse_args()

mps = MPSConfig(args.database[0].name)
session = mps.session
verbose = args.verbose

if (args.prod_location):
  if not os.path.isdir(args.prod_location):
    os.makedirs(args.prod_location)

arch_location=None
if (args.archive_location):
  arch_location = args.archive_location
  if not os.path.isdir(arch_location):
    os.makedirs(arch_location)

if (args.fault_states):
  exportFaultStates(args.fault_states, session.query(models.FaultState).all(), session, arch_location)

if (args.device_inputs):
  exportDeviceInputs(args.device_inputs, session.query(models.DeviceInput).all(), session,
                     '$PHYSICS_TOP/mps_configuration/{0}/bypass/'.format(args.version[0]),
                     args.prod_location, arch_location)

if (args.analog_devices):
  exportAnalogDevices(args.analog_devices, session.query(models.AnalogDevice).all(), session,
                      '$PHYSICS_TOP/mps_configuration/{0}/bypass/'.format(args.version[0]),
                      args.prod_location, arch_location)

if (args.beam_destinations):
  exportBeamDestinations(args.beam_destinations,
                         session.query(models.BeamDestination).all(),
                         session.query(models.BeamClass).all(), session,
                         arch_location)

if (args.faults):
  exportFaults(args.faults, session.query(models.Fault).all(), session, arch_location)

if (args.apps):
  exportApps(args.apps, session.query(models.ApplicationCard).all(), session, arch_location)

if (args.conditions):
  exportConditions(args.conditions, session.query(models.Condition).all(), session, arch_location)

if (args.link_nodes):
  exportLinkNodeDatabases(args.link_nodes, session)

session.close()

